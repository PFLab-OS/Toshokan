{% import 'macro.tpl' as helper %}
# 例外からの復帰

{{ helper.sample_info() }}

今回のサンプルでは、コンソールから1-2を入力する事により、異なるサンプルコードを実行できます。以下の説明に対応するサンプルを実行してください。


## 1. 例外からの復帰
`iret`命令を用いると例外（や割り込み）から復帰する事ができます。ただし、例外が発生する時は何らかのエラーが発生しているので、例外の発生要因を解消しないと正常に復帰する事ができず、再度例外が発生してしまいます。（例外の無限ループ）

ひとまず例外の発生要因を解消しないとどうなるか確認してみてください。恐らく処理が戻ってこない事でしょう。前回同様RIPの値を取得し、RIPの値がソースコードのどの行に対応するのか調べてみると、例外ハンドラ（int.Sのint_handler1）内か、例外発生箇所（friend.ccの除算命令部分）のどちらかを指しているはずです。

## 2. 例外要因の解消
前回示した通り、例外を発生させているコードは以下のインラインアセンブリコードです。変数zeroの値を用いて1を割るというコードです。

```cc
// friend.cc
  asm volatile("divl %2" ::"a"(1), "d"(0), "m"(zero));  // 1 / zero
```

さて、例外ハンドラの中で変数zeroの値を0以外に書き換えれば、例外が発生せずに除算が終了し、実行を継続できるはずです。

そこで、今回のサンプルでは、例外ハンドラに以下の１行を追加してみました。

```asm
movl $1, (zero)                 // zero = 1
```
これは変数zeroの値を1に書き換えるというものです。このサンプルは上手く動くでしょうか・・・？


## 今回のまとめ
- 例外発生要因を解消して例外ハンドラから戻ると、例外が発生したソフトウェアの実行を継続できる。
