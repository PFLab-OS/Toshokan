{% import 'macro.tpl' as helper %}
# ページの割当て

{{ helper.sample_info() }}

## サンプルコードの解説
まずはfriend.ccを開き、friend_main関数を見てみましょう。

HINT: 今回もコードの細かい処理を理解する必要はありません。その解説は後ほど行うので、今は「どういう処理が行われているか大雑把に把握する」事ができればOKです。

1. 仮想メモリ0x80000000(vaddr1)からの4KBに物理メモリ0x40000000からの4KBを割り当てます。

```cc
  // setup a page
  pt.entry[(vaddr1 % k2MB) / k4KB] =
      0x40000000 | (1 << 0) | (1 << 1) | (1 << 2);
```

2. 仮想メモリ0x80000000の8byte（つまり物理メモリ0x40000000の8byte）を表示し、ユーザーからの入力を待ちます。

```cc
  show_memdata(vaddr1);
  wait_input(1);
```

3. 仮想メモリ0x80000000(vaddr1)からの4KBに物理メモリ0x4000<font color="red">1</font>000からの4KBを割り当てます。

```cc
  // remap the page
  pt.entry[(vaddr1 % k2MB) / k4KB] =
      0x40001000 | (1 << 0) | (1 << 1) | (1 << 2);

  // flush TLB
  asm volatile("invlpg (%0)" ::"r"(vaddr1) : "memory");
```

4. 再度仮想メモリ0x80000000の8byteを表示し、ユーザーからの入力を待ちます。この際参照されるのは、物理メモリの0x4000<font color="red">1</font>000の8byteになるはずです。

```cc
  show_memdata(vaddr1);
  wait_input(2);
```

5. 仮想メモリ0x80001000(vaddr2)からの4KBに物理メモリ0x40000000からの4KBを割り当て、更に仮想メモリ0x80002000(vaddr3)からの4KBに物理メモリ0x40001000からの4KBを割り当てます。
```cc
  // setup other pages
  pt.entry[(vaddr2 % k2MB) / k4KB] =
      0x40000000 | (1 << 0) | (1 << 1) | (1 << 2);
  pt.entry[(vaddr3 % k2MB) / k4KB] =
      0x40001000 | (1 << 0) | (1 << 1) | (1 << 2);
```

6. 仮想メモリ0x80001000の8byteと仮想メモリ0x80002000の8byteを表示し、ユーザーからの入力を待ちます。
```cc
  show_memdata(vaddr2);
  show_memdata(vaddr3);
  wait_input(3);
}
```

## 実際に試してみる

コードをなぞれば、出力は以下の通りになる事が期待できますね。

1. 仮想メモリ0x80000000の表示、参照先は0x40000000
2. 〜入力待ち〜
3. 仮想メモリ0x80000000の表示、参照先は0x40001000
4. 〜入力待ち〜
5. 仮想メモリ0x80001000の表示、参照先は0x40000000
6. 仮想メモリ0x80002000の表示、参照先は0x40001000

つまり、
- 1と3では同じ仮想メモリを参照しているが、異なるデータが表示される
- 1と5では異なる仮想メモリを参照しているが、同じデータが表示される
- 3と6も同様
となるはずです。実際にそうなるでしょうか？ぜひ実際に試してみてください。

## 意味を考えてみよう

連続領域の
既に割り当てられている領域を再割当てて参照
メモリの移動
空きメモリ

どう活用できるか

## 今回のまとめ
- ページと呼ばれる4KBのメモリ領域ごとに、物理メモリを仮想メモリへ割り当て
- メモリの移動が非常に低いコストで実現可能
