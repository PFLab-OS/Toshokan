{% import 'macro.tpl' as helper %}
# ページングの階層構造

## 素朴なページ管理
前回までのサンプルで、以下のようにすればページを設定できる事が分かったと思います。

- ページテーブルの特定のエントリに、ページの物理アドレス（＋α）を設定
- ページテーブルのエントリサイズは8byte
- 隣のエントリに書き込むと、（仮想メモリ上）隣のページを設定可能

これらはx64アーキテクチャの仕様ですが、そこそこ素朴なような感じがしませんか？

素朴というのは、もし皆さんが「仮想メモリから物理メモリへの4KB単位での変換」をするとしたら、64bit（アドレス長、8byte）の配列を作り、各々のエントリに物理アドレスを書き込んで行くのが一番簡単だからです。x64のページテーブルも正しくそういう構成になっていますね。

![](img1.jpg)

## 2MB単位での階層

さて、仮想アドレス0x200000（先頭から2MB）が位置するページを管理する事を考えてみましょう。

上の通りなら、`0x200000 / 0x1000 = 512 （2MB/4KB=512）`なので、エントリ512を用いる事になります。しかし、x64の場合は実はもう少し複雑です。

![](img2.jpg)

x64では、このようにまた別の配列（ページテーブル）を用意し、管理しています。これはx64の仕様なわけですが、とはいえ、幾つか疑問点が沸いてきますね。

1. なぜわざわざ複雑な構造になっているのか？
1. 複数のページテーブルをどうやって管理するのか？

まず最初の問いから考えていきましょう。わざわざこのような複雑な仕様になっているのは何かしらの意図があるわけで。

仮に、仮想メモリから物理メモリへの変換テーブルを、一つのテーブルで賄うとし、かつ各エントリは4KBのページを管理、仮想メモリ空間は4GBとしてみましょう。そうするとテーブルのエントリ数は、`4GB/4KB=1048576`、各エントリサイズが8byteなので、テーブルの大きさは`1048576*8byte=8MB`になってしまいます。4GBものメモリ空間を消費しつくすアプリケーションをそう多くないので、一部のエントリは使われないわけですが、エントリが使われているにせよ、使われていないにせよ、変換テーブルだけで8MBメモリを消費してしまうわけです。ちなみに、x64の仮想メモリ空間の大きさは16TBなので、更に変換テーブルは巨大になってしまいますね。

ページテーブルを分ける事のメリットは、使っていない仮想メモリ領域分のページテーブルを生成しない事で、メモリを節約できる事です。

次の問いの答えは、「ページテーブルを管理する、新しいページテーブル（ページディレクトリ、PD）を用意する」という物です。図にしてみましょう。

![](img3.jpg)

要点は以下の通りです。

- ページディレクトリの構造はページテーブルと同じ
- ページディレクトリが指し示す先はページテーブルの物理アドレス（ページテーブルを管理対象のページと見なす）
- ページディレクトリは2MB単位で仮想メモリを管理

直感的で無くなってきたので、仮想アドレスと物理アドレスの変換をまとめてみましょう。

1. 変換したい仮想アドレスが「どの2MBブロックに入っているか」を調べる。
1. ページディレクトリ内の対応エントリを見つける。
1. 対応エントリが指すページテーブルを参照（ページテーブルが設定されている場合）
1. 仮想アドレスが「2MBブロック中でどの4KBブロックに入っているか」を調べる。
1. ページテーブル内の対応エントリを見つける。
1. 対応エントリが指すページを参照

## 更に階層化
ページディレクトリ（PD）のエントリ数は512なので、このままでは`512*2MB=1GB`しかメモリを管理できません。そこで、x64では更にページディレクトリポインタテーブル(PDPT)、ページマップレベル4テーブル(PML4T)が導入されています。IntelのSoftware Developer's Manualの中の図を見てみましょう。

![](img4.png)

この図では、仮想アドレスのビット列を抜き出す事で各PT,PD,PDPT,PML4Tのエントリ番号を求めていますが、本質的にはここまでの説明と同じで、「テーブルの各エントリがどれだけの仮想メモリを管理できるか（PTなら4KB、PDなら2MB...）」を考えれば問題なく変換できます。実際に上の図のようなビット列の抜き出し操作で、きちんと各々のテーブルのエントリ番号が求まる事を確認してみると良いでしょう。

## サンプルコードの解説

サンプルコードの流れは以下の通りです。

1. 仮想メモリ0x80000000（vaddr1）からの4KBにページ割当
1. ユーザからの入力待ち（step 1/2）
1. 新しいページテーブル（pt2）を用意
1. 仮想メモリ0x80200000（vaddr2）からの4KBにページ割当
1. ユーザからの入力待ち（step 2/2）

新しいページテーブルを用意しなければいけない所がポイントです。ページディレクトリのエントリ番号（pd.entry[]に渡すインデックス）がvaddr1とvaddr2で異なる値になるのも確認してみてください。

またstep1/2で、QEMUモニタ上から0x80200000にアクセスすると`Cannot access memory`が表示されますが、step2/2ではアクセスできるようになっているのも確認してみてください。


## 今回のまとめ

- x64のページングは4段階で階層管理されている。
- 階層管理されているのは、使用していない変換テーブル（ページテーブル等）分のメモリを節約するため

