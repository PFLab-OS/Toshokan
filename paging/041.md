paging/041: ２つの仮想メモリ空間
==========================

今回使用するディレクトリ：[sample/paging/041](https://github.com/PFLab-OS/Toshokan/tree/master/sample/paging/041)

Attention: 今回は[paging/024](024.md)のソースに改変を加えたコードです。

[paging/024](024.md)では、アプリケーションのメモリ空間をページテーブルエントリを書き換える事で実現していました。しかし一般的なOSでは、アプリケーションのメモリ空間を切り替える際に別の方法を用いています。今回はその手法を学びましょう。

CR3レジスタの更新
---------------------------------
[paging/024](024.md)では、アプリケーションが使用するメモリ領域がたったの4KBでした。しかし現実のアプリケーションでは、もっと多くのメモリ領域を使います。アプリケーションが１ページ（4KB）しか使わない場合はページテーブルエントリの１つを書き換えれば良かったのですが、２ページ使う場合はページテーブルエントリを２つ書き換えなければいけません。３ページの場合は３つ書き換え、４ページの場合は４つ書き換えて・・・とアプリケーションのメモリ使用量が増えれば増えるほどコンテキストスイッチコストが増加していきます。

そんな事をするくらいなら、そもそもPML4T自体を入れ替えてしまえばいいじゃないか！というのが今回のお話です。

PML4TのアドレスはCR3レジスタに代入されているのですが、新しいPML4T（とPDPT等のページ構造）のアドレスをCR3レジスタに代入してしまえば、全く異なる仮想メモリ空間に瞬時に切り替える事ができます。簡単ですね。

アプリケーション間でのカーネルの共有
---------------------------------
簡単ですね、と書いたのですが、一つだけ注意点があります。

仮想メモリ空間の切り替えはOSカーネルの仕事なのですが（アプリケーションが自由に仮想メモリ空間を切り替えられるといろいろ問題が起きるので）、切り替える前と後の両方でOSカーネルが走らないといけません。

以下のコードで考えてみましょう。`func1()`を実行し、CR3レジスタ更新後、`func2()`を実行する、というものです。

``` cpp
// 切り替え前
func1();
asm volatile("movq %0, %%cr3" ::"r"((uint64_t)pml4t + 0x80000000UL)); // CR3レジスタ更新
// 切り替え後
func2();
```

もしもCR3レジスタの更新によってfunc2()が存在する仮想メモリ上のページが未割り当てになってしまったら、func2()は実行できずにCPUが停止してしまいますよね。あるいはfunc2()のページに別の物理ページを割り当ててしまうと、func2()には飛んだ後で意図しない処理が走る事になるでしょう。

もう少し考えてみましょう。そもそもfunc1()の呼び出し、CR3レジスタ更新、func2()の呼び出しをしているこのコード自体も、どこかの物理ページに置かれており、仮想ページにマップされているわけですよね。もしこの仮想ページが別の物理ページに割り当たってしまったらどうなるでしょうか？CR3レジスタ更新直後に意図しない処理を実行する事になりそうです。

このような事を起こさないため、OSカーネルのページはアプリケーション間で共有されています。我々は今OSカーネルを作っているわけではないのですが、サンプルコードでも同様の事を行っているので、是非この点に注意しつつ、コードを読んでみてください。

コードを読んでみよう
---------------------------------
今回のコードは動かすと、[paging/024](024.md)と同じ結果になるはずです。皆さんも手元で動かしてみてください。

それではコードを読んでいきましょう。まずは簡単な所から見ていきましょうか。

アプリケーションのコンテキストスイッチは、[CR3レジスタへのPML4Tアドレスの代入](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/041/friend.cc#L82)で実現されるようになりました。app1とapp2のページ構造は[create_pagetable関数](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/041/friend.cc#L10-L28)で行われています。些細な部分（ページ構造に使うメモリ領域の先頭アドレスを引数で渡している等）が違うものの、お馴染みのコードですよね。

app1用のページ構造は、[物理メモリ0x80310000からの16KBを使用する](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/041/friend.cc#L37-L38)事にしました。一方app2は、[0x80314000からの16KBを使用する](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/041/friend.cc#L39-L40)事にします。この16KBは、先頭から4KBづつ、PML4T、PDPT、PD、PTに使用します。

また、app間で共有する仮想メモリ領域も準備します。[ページディレクトリを一つ用意](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/041/friend.cc#L41)し、[物理メモリ0x80000000からの連続した1GBが割当たるよう、2MBヒュージページで初期化](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/041/friend.cc#L45-L48)します。この領域はfriend.ccが動作する領域なので、[仮想メモリの0-1GBにマップされる](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/041/friend.cc#L23-L24)ようにします。

共有メモリ
---------------------------------
今回の趣旨とは少し異なるのですが、ちょうど良い機会なので共有メモリについても説明しておきましょう。

共有メモリとは、複数のプロセス間でメモリを共有する仕組みの事です。プロセス同士が通信するための仕組み（IPC）の一つですが、共有メモリの特徴としてカーネルを一切経由する事なく高速に通信する事ができます。詳しい話はここでは扱わないので、興味がある方は調べてみてください。

さてこの共有メモリですが、カーネルのメモリ空間をアプリケーション間で共有するという話に凄く似ていると思いませんか？OSカーネルのメモリ空間も一種のアプリケーション間の共有メモリなわけですね。

OSが提供する機能の多くがMMUの機能を活用して実装されています。MMUをきちんと理解した今なら、これらの機能の実装も凄く簡単そうに思えませんか？

理解度テスト
---------------------------------

Q. ページ構造の細部が異なる２つの仮想メモリ空間を作りたい。仮想メモリと物理メモリのマッピングの大半は共有されているが、PML4Tは仮想メモリ空間ごとにそれぞれ作らなければならないだろうか？ただし、仮想メモリ空間の切り替えはCR3レジスタの切り替えだけで済ませる物とする。（ページテーブルエントリ等は触らない）
[gimmick:question({ answer: 1, list: ["同じPML4Tを使う事ができる", "別のPML4Tを用意する必要がある"]})]()

[このセクションの目次に戻る](index.md)