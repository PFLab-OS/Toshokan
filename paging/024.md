paging/024: コピーを使わずにマルチタスク
==========================

今回使用するディレクトリ：[sample/paging/024](https://github.com/PFLab-OS/Toshokan/tree/master/sample/paging/024)

前回、複数のプログラムを同一のメモリ領域上で動かすにはどうすれば良いか考えました。前回はメモリコピーというソフトウェア的なアプローチで考えましたが、今回はハードウェア的なアプローチを考えてみます。

CPUをだます
------------------------------
複数のプログラムAとBを同一のメモリ領域で動かすためには、0x400000というアドレス領域を参照した時のデータがタイミングによってプログラムAだったり、プログラムBだったりしなければいけないわけです。ただし、ここで重要なのは「CPUが0x400000を参照した時にプログラムAやBが読めれば良いだけで、プログラムAやBがメモリの0x400000にある必要はない」という事です。

恐らく皆さんの頭の中にはてなマークが沢山浮かんだ浮かんだ事でしょう。図で説明してみますね。

![024_1.svg](024_1.svg)

CPUは0x400000へメモリアクセスをしようとすると、途中で謎の存在が挟まった上で、実際のメモリアクセスが発生します。メモリアクセスが終わり次第、謎の存在を経由してCPUに完了通知を送ります。この時、実際のメモリアクセス先が0x400000である必要はありません。CPUが「自分は0x400000へメモリアクセスした！そしたら期待通りの結果が帰ってきた！」と思い込む事が大事なのです。要するに、謎の存在がCPUを騙す事ができれば良いわけですね。

これの何が良いかと言うと、謎の存在がちょっと挙動を変えるだけで、0x400000が参照された時のデータを変える事ができるのです。例えばこんな感じで。

![024_2.svg](024_2.svg)

CPUは相変わらず0x400000にアクセスしたつもりになっていますが、実際に読み書きしているデータはプログラムAでは無く、プログラムBになっていますね。これならメモリをコピーしなくても、プログラムAとプログラムBを0x400000からのメモリ領域で動かせそうです。

種明かしをすると、この「謎の存在」はMMU（Memory Management Unit）と呼ばれる物です。実はIntel CPUではMMUがCPUの中に内蔵されているので、CPUが騙されていると書くより「CPUの中の演算ユニットが騙されている」とするのが正しいのでしょうか。まあでも「CPUがだまされている」と書いた方が説明しやすいので、この後も同じような説明を続けさせてください。

２つのメモリ
------------------------------

CPUはメモリアクセスをする際にMMUによって騙されている、という話をしました。CPUは騙されている事に気づいておらず、「0x400000にアクセスしたらプログラムBがいるんだろうな」というイメージを持っているわけです。

![024_3.svg](024_3.svg)

このCPUが思い描いているメモリを「仮想メモリ」と呼び、実際のメモリ（基盤に刺さっているメモリ）の事を「物理メモリ」と呼びます。「仮想」という言葉は、「実際には存在しないけれども、あたかも存在しているかのように見せかける」という意味ですから、「仮想メモリ」は「実際にはそんなメモリは存在しないけれども、あたかもCPUの視点ではそのようなメモリが存在しているように見えるメモリ」という事になります。

MMUを使って書き直してみよう
------------------------------

それでは[paging/023](023.md)と同様の事をMMUを用いて実現してみましょう。

説明を簡単にするためにアドレスは0x400000ではなく、[0xC0000000にしました](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/app.ld#L4)。0x400000と0xC0000000では本質的に何も変わらないのですが、0xC0000000の場合、paging/001からpaging/014までの説明の際に使用したアドレスなので、同じコードにできるからです。（それならそもそも最初から0x400000でやれば良かったじゃん！という話なのですが、いろいろ考えると0xC0000000の方が説明がしやすかったので・・・）

この辺りは、前の説明で出てきたコードですね。きちんと説明していないので何をやっているのか分からないかもしれませんが、もう少しお待ち下さい。

https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L15-L30

app1とapp2は仮想メモリの0x500000ULと0x600000ULに読み込みます。先に種明かしをしておくと、これは物理メモリの0x80500000ULと0x80600000ULに読み込まれます。この辺の設定は上のコードがやっているので、上のコードについての説明があった後でもう一度ここを振り返ってみてください。
https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L37-L38

さあ、ここからが本題です。pt1[0]に0x80500000ULという物理メモリアドレスを設定しています。pt1[0]に物理メモリアドレスを設定すると0xC0000000からの仮想メモリと同一になるみたいだ、という話は[paging/011](paging/011.md)でやりましたね。
https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L44

次の行はMMUのキャッシュをクリアするためのアセンブリコードです。今は説明を割愛させてください。
https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L45

さあ、これで0xC0000000を参照するとapp1を読み書きできるので、app1を実行してしまいます。
https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L46

[paging/023](023.md)ではapp1実行前にメモリコピーをしていましたが、今回はpt1というただの配列への書き込み（＋謎のアセンブリ命令発行）だけですね。メモリコピーと比較すると、CPU的には凄く軽い処理です。しかも、コンテキスト退避の時は何もしなくて大丈夫です。

次はapp2の実行です。app1の時と同様、pt1[0]に物理メモリアドレス0x80600000ULを設定して実行します。

https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L59-L61

app1に戻ってきた時も同じ処理ですね。

https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70-L72

実際に動かしてみよう
------------------------------

MMUを使った場合のメモリ切り替えコードを紹介しましたが、実際にこれで上手く動くのでしょうか？

きちんと動くかどうかは皆さん自身が試してみてください。

[このセクションの目次に戻る](index.md)
