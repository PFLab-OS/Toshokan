paging/024: コピーを使わずにマルチタスク
==========================

今回使用するディレクトリ：[sample/paging/024](https://github.com/PFLab-OS/Toshokan/tree/master/sample/paging/024)

今回も複数のプログラムを同一のメモリ領域上で動かす方法について考えていきましょう。前回はメモリコピーというソフトウェア的なアプローチで考えましたが、今回はハードウェア的なアプローチを考えてみます。

CPUをだます
------------------------------
複数のプログラムAとBを同一のメモリ領域で動かすためには、0x400000というアドレス領域を参照した時のデータがタイミングによってプログラムAだったり、プログラムBだったりしなければいけません。ただし、ここで重要なのは「CPUが0x400000を参照した時にプログラムAやBが読めれば良いだけで、プログラムAやBが実際にメモリの0x400000にある必要はない」という事です。

恐らく皆さんの頭の中にはてなマークが沢山浮かんだ事でしょう。図で説明してみますね。

![024_1.svg](024_1.svg)

CPUは0x400000へメモリアクセスをしようとすると、途中で謎の存在が挟まった上で、実際のメモリアクセスをします。メモリアクセスが終わり次第、謎の存在を経由してCPUに完了通知を送ります。この時、実際のメモリアクセス先が0x400000である必要はありません。CPUが「自分は0x400000へメモリアクセスした！そしたら期待通りの結果が帰ってきた！」と思い込む事が大事なのです。要するに、謎の存在がCPUを騙す事ができれば良いわけですね。

これの何が良いかと言うと、謎の存在がちょっと挙動を変えるだけで、0x400000が参照された時のデータを変える事ができるのです。例えばこんな感じで。

![024_2.svg](024_2.svg)

CPUは相変わらず0x400000にアクセスしたつもりになっていますが、実際に読み書きしているデータはプログラムAでは無く、プログラムBになっていますね。これならメモリをコピーしなくても、プログラムAとプログラムBを0x400000からのメモリ領域で動かせそうです。

種明かしをすると、この「謎の存在」はMMU（Memory Management Unit）と呼ばれるハードウェアです。最近の少しリッチなアーキテクチャには実装されていて、x86系 CPUにはもちろん、ARM系のCPUの多くにも実装されています。

x86系 CPUではMMUがCPUの中に内蔵されているので、CPUが騙されていると書くより「CPUの中の演算ユニットが騙されている」とするのが正しいのでしょうか。まあでも「CPUがだまされている」と書いた方が説明しやすいので、この後も同じような説明を続けさせてください。

２つのメモリ
------------------------------

CPUはメモリアクセスをする際にMMUによって騙されている、という話をしました。CPUは騙されている事に気づいておらず、「0x400000にアクセスしたらプログラムBがいるんだろうな」というイメージを持っているわけです。

![024_3.svg](024_3.svg)

このCPUが思い描いているメモリを「仮想メモリ」と呼び、実際のメモリ（基盤に刺さっているメモリ）の事を「物理メモリ」と呼びます。「仮想」という言葉は、「実際には存在しないけれども、あたかも存在しているかのように見せかける」という意味ですから、「仮想メモリ」は「実際にはそんなメモリは存在しないけれども、あたかもCPUの視点ではそのようなメモリが存在しているように見えるメモリ」という事になります。

MMUを使って書き直してみよう
------------------------------

それでは[paging/023](023.md)と同様の事をMMUを用いて実現してみましょう。

説明を簡単にするためにアドレスは0x400000ではなく、[0xC0000000にしました](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/app.ld#L4)。0x400000と0xC0000000では本質的に何も変わらないのですが、0xC0000000の場合、paging/001からpaging/014までの説明の際に使用したアドレスなので、同じコードにできるからです。（それならそもそも最初から0x400000でやれば良かったじゃん！という話なのですが、いろいろ考えると0xC0000000の方が説明がしやすかったので・・・）

friend.ccがいろいろ変更されたので、一つづつ見ていきましょう。

[この辺り](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70)は、前の説明で出てきたコードですね。きちんと説明していないので何をやっているのか分からないかもしれませんが、もう少しお待ち下さい。

app1とapp2は仮想メモリの0x500000ULと0x600000ULに[読み込み](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70)ます。先に種明かしをしておくと、これは物理メモリの0x80500000ULと0x80600000ULに読み込まれます。（本当にそうかな？と思った人はqemuのデバッグコンソールを使って調べてみてください）この辺の設定は上のコードがやっているので、上のコードについての説明があった後でもう一度ここを振り返ると、「なるほど！」となると思います。

さあ、ここからが本題です。pt1[0]に0x80500000ULという物理メモリアドレスを[設定](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70)しています。pt1[0]に物理メモリアドレスを設定すると0xC0000000からの仮想メモリと同一になるみたいだ、という話は[paging/011](paging/011.md)でやりましたね。


[次の行](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70)はMMUのキャッシュをクリアするためのアセンブリコードです。今は説明を割愛させてください。

さあ、これで0xC0000000を参照するとapp1を読み書きできるので、app1を[実行して](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70)しまいます。

[paging/023](023.md)ではapp1実行前にメモリコピーをしていましたが、今回はpt1というただの配列への書き込み（＋謎のアセンブリ命令発行）だけですね。メモリコピーと比較すると、CPU的には凄く軽い処理です。しかも、コンテキスト退避の時は何もしなくて大丈夫です。

次はapp2の実行です。app1の時と同様、pt1[0]に物理メモリアドレス0x80600000ULを[設定して実行](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70)します。

app1に戻ってきた時も[同じ処理](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/024/friend.cc#L70)ですね。

実際に動かしてみよう
------------------------------

MMUを使った場合のメモリ切り替えコードを紹介しましたが、実際にこれで上手く動くのでしょうか？

きちんと動くかどうかは皆さん自身が試してみてください。上手く動けば、前回と同じ出力結果が得られるはずです。

[このセクションの目次に戻る](index.md)
