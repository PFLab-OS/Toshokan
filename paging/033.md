paging/033: アドレス変換
==========================

今回使用するディレクトリ：[sample/paging/032](https://github.com/PFLab-OS/Toshokan/tree/master/sample/paging/032)

Attention: paging/032のコードを引き続き使用します。

これまで「pt1[0]が0xC0000000からの4KBのページに対応する」という事を皆さんに信じてもらって進めてきました。今回は、なぜpt1[0]が0xC0000000というアドレスと対応しているのか、きちんと説明します。（もしかしたら勘の良い人は前回の説明だけで理解していたかもしれませんが）

仮想メモリアドレスから物理メモリアドレスを算出する
---------------------------------

[Intel SDM](/document.md#Intel%C2%AE_64_and_IA-32_Architectures_Software_Developer%E2%80%99s_Manual) `Vol.3`, `4.5 4-LEVEL PAGING`, `Figure 4-8. Linear-Address Translation to a 4-KByte Page using 4-Level Paging`の図には、仮想アドレスを物理アドレスに変換する方法が書かれています。

解説すると、64bitの仮想アドレスがあった時、

1. 上位16bit（48bit-63bit）は捨てる。
1. PML4TのアドレスをCR3から読み込む。
1. 残った48bitの上位9bit(39bit-47bit)を切り取り、PML4Tのエントリ番号とする。
1. PML4Tの該当エントリ番号にアクセスし、PDPTのアドレスを取得する。
1. 残った39bitの上位9bit(30bit-38bit)を切り取り、PDPTのエントリ番号とする。
1. PDPTの該当エントリ番号にアクセスし、ページディレクトリのアドレスを取得する。
1. 残った30bitの上位9bit(21bit-29bit)を切り取り、ページディレクトリのエントリ番号とする。
1. ページディレクトリの該当エントリ番号にアクセスし、ページテーブルのアドレスを取得する。
1. 残った21bitの上位9bit(12bit-20bit)を切り取り、ページテーブルのエントリ番号とする。
1. ページテーブルの該当エントリ番号にアクセスし、ページのアドレスを取得する。
1. 残った12bit(0bit-11bit)をページ内オフセットとする。
1. ページのアドレスとページ内オフセットを足した値が物理アドレス

例えば、前回のコードのページング設定を元に、0xC0200123という仮想アドレスを物理アドレスに変換してみましょう。

1. 0xC0200123の上位16bitは捨てる。→0xC0200123
1. PML4TのアドレスをCR3から読み込む。→[ pml4t](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/032/friend.cc#L26)
1. 残った48bit（0xC0200123）の上位9bit(39bit-47bit)を切り取り、PML4Tのエントリ番号とする。→エントリ番号は0、残った39bitは0xC0200123
1. PML4Tの該当エントリ番号（0）にアクセスし、PDPTのアドレスを取得する。→[pdpt](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/032/friend.cc#L17)
1. 残った39bit（0xC0200123）の上位9bit(30bit-38bit)を切り取り、PDPTのエントリ番号とする。→エントリ番号は3、残った30bitは0x200123
1. ページディレクトリの該当エントリ番号（3）にアクセスし、ページテーブルのアドレスを取得する。→[pd2](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/032/friend.cc#L19)
1. 残った30bit（0x200123）の上位9bit(21bit-29bit)を切り取り、ページディレクトリのエントリ番号とする。→エントリ番号は1、残った21bitは0x123
1. ページディレクトリの該当エントリ番号（1）にアクセスし、ページテーブルのアドレスを取得する。→[pt2](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/032/friend.cc#L21)
1. 残った21bit（0x123）の上位9bit(12bit-20bit)を切り取り、ページテーブルのエントリ番号とする。→エントリ番号は0、残った12bitは0x123
1. ページテーブルの該当エントリ番号（0）にアクセスし、ページのアドレスを取得する。→[0x80700000](https://github.com/PFLab-OS/Toshokan/blob/master/sample/paging/032/friend.cc#L31)
1. 残った12bit(0bit-11bit)をページ内オフセットとする。→ページ内オフセットは0x123
1. ページのアドレス（0x80700000）とページ内オフセット（0x123）を足した値が物理アドレス→0x80700123

なぜこのようなbit操作で仮想アドレスから物理アドレスが求まるのでしょうか？考えてみましょう。

ページの先頭アドレスが分かっている場合、オフセットを足せば物理アドレスが求まるのは、皆さんですよね。ページは4KBなので、オフセットは0~0xFFFとなります。0xFFFは2進数で111111111111、つまり12bitでオフセットを表現できる事になります。ページは4KBにアラインされているので、仮想アドレスの下位12bitを切り取れば、ページのオフセットになりますよね。

復習ですが、ページテーブルは4KB×512エントリで2MBの領域を管理していましたね。あるページがページテーブル内のどのエントリで管理されているかは、どうすれば求まるでしょうか？例えば、2MBの仮想メモリ中で先頭から0Bの場所にあるページは、第0エントリで管理されているはずです。同様に、2MBの仮想メモリ中で先頭から4KBの場所にあるページは、第1エントリで管理されているはずですよね。、2MBの仮想メモリ中で先頭から8KBの場所にあるページは、第2エントリで管理されていて・・・とどんどん辿っていくと、2MBの仮想メモリ中で先頭からn×4KBの場所にあるページは第nエントリで管理されている、という事になります。

与えられた仮想アドレスが0~2MBのどこか（つまり21bitで表現されているアドレス）だとしましょう。まずそのアドレスのページの先頭を計算するために、4KBでアラインします。オフセットを０にすればページの先頭になるので、下位12bitをクリアします。これを4KBで割った値がエントリ番号になるわけですが、4KBで割る＝12bit右シフトとするのと同値（例えば、0から12KBの場所にあるアドレスは0x3000で、これを12bit右シフトすると3になる）です。21bitの値を12bit右シフトして得られる値というのは、元の21bitの値の上位9bit(12bit-20bit)を切り抜いた値と同じですね。これは正しく「21bitの上位9bit(12bit-20bit)を切り取り、ページテーブルのエントリ番号とする」という先ほどの手順そのものです。

ページディレクトリやPDPT、PML4Tも同様に考える事ができるので、是非皆さんも手元で計算して考えてみてください。

上位16bitはどこへ？ 〜 canonical address 〜
---------------------------------

先程、上位16bitは捨てるを書きました。なぜ上位16bitを使用しないのでしょうか？

上位16bitを使用する場合、PML4Tの上に新しいPML5Tを設ける必要があります。実際、Intelは5-Level Pagingの仕様を公開していますし、Linuxカーネルも対応しています。（ただし、恐らくこれを書いている時点では5-Level PagingをサポートしているIntel製CPUは無いはずです。私は詳しくないので間違っているかもしれませんが）最初から5-Level、いや64bitのアドレス空間をフルに活用するため6-Level Pagingをサポートすれば良かったようにも思えますよね。

この理由は、階層が増えれば増えるほどアドレス変換が複雑になり、プログラムの実行時間を低下させるからです。先程のアドレス変換の手順でさえ、PML4T、PDPT、と何段階もページ構造を辿っていかなければなりませんでしたが、これにPML5Tが増えるともうひと手間増えますからね。仮想アドレスが出てくる度に物理アドレスに変換しているとMMUの処理速度が遅くなってしまうので、現在のx64アーキテクチャは上位16bitを捨てる、というアドレス変換を行っています。

ただし、これには一つだけ注意点があり、上位16bitは47bit目と同じbitでなければならない、という制約があります。つまり、47bit目が1なら48bit目から63bit目までは全て1、といった具合です。これはcanonical addressと呼ばれており、5-Level Pagingをサポートしているハードウェアとそうでないハードウェアの間で互換性を保つための物と考えられます。

ページテーブルはどのメモリにある？
---------------------------------
皆さんはもうページングのアドレス変換の仕組みをおおよそ理解できたのではないかと思います。皆さんの理解がちゃんと追いついているか幾つか確認してみましょう。

まず、ページテーブルの実体は物理メモリ上にあるのでしょうか？それとも仮想メモリ上にあるのでしょうか？

どうですか？ちゃんと物理メモリと即答できましたか？仮想メモリはあくまで「実体の無い幻想」であって、全てのデータは物理メモリ上にあります。仮想メモリはあくまでMMUがアドレス変換によって生み出した架空の物です。

物理メモリ上のページテーブルに、OSやベアメタルプログラムはどうやってアクセスすれば良いか？

これは答えが２つありますね。一つ目はサンプルコードがやっているように（皆さんにまだきちんと説明していませんが）、ページテーブルを仮想メモリにマッピングしてしまい、仮想メモリ越しに設定するという方法です。２つ目はページング機構を無効化し、物理メモリを直接触る事でページテーブルを設定する方法です。ただし、64bitで動作中はページング機構を無効にする事はできません。しかし、起動直後はページテーブルが設定されていないので、ページングが有効化されていない状態（16bitや32bitで動作中）でページテーブルを設定し、その上で64bitモードに突入します。

理解度テスト
---------------------------------

Q. 仮想アドレス0x8080808000の場合、PDPTのアドレスはPML4Tの第何エントリに格納されているでしょうか？（最初のエントリは第0エントリとする）
[gimmick:question({ answer: 1, list: ["0", "1", "2", "4", "8"]})]()

Q. 仮想アドレス0x8080808000の場合、ページテーブルのアドレスはページディレクトリの第何エントリに格納されているでしょうか？（最初のエントリは第0エントリとする）
[gimmick:question({ answer: 3, list: ["0", "1", "2", "4", "8"]})]()

Q. 現在のx64アーキテクチャにおいて、仮想アドレス0x1000000000000は有効でしょうか？
[gimmick:question({ answer: 1, list: ["有効である", "有効でない"]})]()

Q. 現在のx64アーキテクチャにおいて、仮想アドレス0x800000000000は有効でしょうか？
[gimmick:question({ answer: 1, list: ["有効である", "有効でない"]})]()

[このセクションの目次に戻る](index.md)
