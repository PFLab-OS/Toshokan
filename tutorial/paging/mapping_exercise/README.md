
# 演習：ページの割当て

## 演習
本ページのサンプルは演習形式です。無編集では期待通りに動作しませんが、適切にコードを修正し、`make`する事で、サンプルプログラムを実行できます。

## ページング自体の機能
CPUは以下のような機能を提供しています。

- 既に割り当てられているページに、別のページを割り当て
- 仮想ページに物理ページを「敢えて」割り当てない。
- 複数の仮想ページから一つの物理ページを参照

後のサンプルで実際に試してみるので、それぞれ確認してみてください。

## ページングによって実現できる事
「ページングそれ自体がどういう機能を有しているか」以上に、「それをどう活用できるか」の方がより重要です。上記のページングの機能を活用すると、例えば以下のような事ができます。

- メモリの共有（複数の仮想ページから一つの物理ページを参照）
- メモリの移動（移動前のページ割当を解除し、移動先にページ割当）
- メモリの節約（使用してない仮想メモリに物理メモリを割り当てない）

もちろん、これらの機能をページングを使わずに実現する事は可能です。例えばメモリの移動は、memmove()関数等を用いれば簡単に実現できそうですよね？大事な事は、ページングを用いれば、今挙げた例を「非常に小さなコストで」実現できる事です。ページングのキモは、メモリの管理に関する多くの操作を、ページテーブルの編集（厳密に書けば、8byteのメモリアクセス＋TLBのフラッシュコスト）のみで実現できるという部分です。

上記の例以外にも、OSは様々な箇所でページングの機構を活用しています。その話はまた別の所で。

## サンプルコードの解説
ページングの機能を実際に実験で確かめてみましょう。

## サンプル
本リポジトリをクローンし、このREADME.mdがあるディレクトリ上で`make`する事で、サンプルプログラムを実行できます。

friend.ccを開き、friend_main関数を見てみましょう。

HINT: 今回もコードの細かい処理を理解する必要はありません。その解説は後ほど行うので、今は「どういう処理が行われているか大雑把に把握する」事ができればOKです。

1. 仮想メモリ0x80000000(vaddr1)からの4KBに物理メモリ0x40000000からの4KBを割り当てます。

```cc
  // setup a page
  pt.entry[(vaddr1 % k2MB) / k4KB] =
      0x40000000 | (1 << 0) | (1 << 1) | (1 << 2);
```

2. 仮想メモリ0x80000000の8byte（つまり物理メモリ0x40000000の8byte）を表示し、ユーザーからの入力を待ちます。

```cc
  show_memdata(vaddr1);
  wait_input(1);
```

3. 仮想メモリ0x80000000(vaddr1)からの4KBに物理メモリ0x4000<font color="red">1</font>000からの4KBを割り当てます。

```cc
  // remap the page
  pt.entry[(vaddr1 % k2MB) / k4KB] =
      0x40001000 | (1 << 0) | (1 << 1) | (1 << 2);

  // flush TLB
  asm volatile("invlpg (%0)" ::"r"(vaddr1) : "memory");
```

4. 再度仮想メモリ0x80000000の8byteを表示し、ユーザーからの入力を待ちます。この際参照されるのは、物理メモリの0x4000<font color="red">1</font>000の8byteになるはずです。

```cc
  show_memdata(vaddr1);
  wait_input(2);
```

5. 仮想メモリ0x80001000(vaddr2)からの4KBに物理メモリ0x40000000からの4KBを割り当て、更に仮想メモリ0x80002000(vaddr3)からの4KBに物理メモリ0x40001000からの4KBを割り当てます。
```cc
  // setup other pages
  pt.entry[(vaddr2 % k2MB) / k4KB] =
      0x40000000 | (1 << 0) | (1 << 1) | (1 << 2);
  pt.entry[(vaddr3 % k2MB) / k4KB] =
      0x40001000 | (1 << 0) | (1 << 1) | (1 << 2);
```

6. 仮想メモリ0x80001000の8byteと仮想メモリ0x80002000の8byteを表示し、ユーザーからの入力を待ちます。
```cc
  show_memdata(vaddr2);
  show_memdata(vaddr3);
  wait_input(3);
}
```

## 実際に試してみる

コードをなぞれば、出力は以下の通りになる事が期待できますね。

1. 仮想メモリ0x80000000の表示、参照先は0x40000000
2. 〜入力待ち〜
3. 仮想メモリ0x80000000の表示、参照先は0x40001000
4. 〜入力待ち〜
5. 仮想メモリ0x80001000の表示、参照先は0x40000000
6. 仮想メモリ0x80002000の表示、参照先は0x40001000

つまり、
- 1と3では同じ仮想メモリを参照しているが、異なるデータが表示される
- 1と5では異なる仮想メモリを参照しているが、同じデータが表示される
- 3と6も同様

となるはずです。実際にそうなるでしょうか？ぜひ実際に試してみてください。

## 未割り当てなページの確認
再度サンプルを実行してみてください。2の時点（ターミナルに`[1/3] press Enter key to go to the next step:`と表示されている時点）で、仮想メモリ0x80001000にはページが割り当てられていないはずですが、この時点でQEMUモニタ上から仮想メモリ0x80001000にアクセスするとどうなるか、確認してみましょう。

`make`を実行中のターミナルはそのままにし、別のターミナルで`make monitor`を実行してみてください。

```
$ make monitor
Silent mode is enabled by default. You can turn it off with 'make V=1'.
>>> connecting to QEMU monitor
QEMU 2.12.0 monitor - type 'help' for more information
(qemu) x /10x 0x80001000
x /10x 0x80001000
0000000080001000: Cannot access memory
```

実体のメモリである物理メモリが割り当てられてないので、「メモリにアクセスできない」と言われますね。

## 今回のまとめ
ページングには以下のような機能がある。（サンプルを通して確認できましたか？）

- 既に割り当てられているページに、別のページを割り当て
- 仮想ページに物理ページを「敢えて」割り当てない。
- 複数の仮想ページから一つの物理ページを参照
