# Toshokanのアーキテクチャ

## hakaseとfriend
hakaseでは馴染み深いLinuxプログラムが、friendではベアメタルプログラム（OSの支援を一切受けず、直接CPU上で実行されるプログラム）が実行されます。このhakaseとfriendが一つのプロセッサ上で同時に稼働し、相互に通信できる事がToshokanの本質です。

一般的なベアメタルプログラムではOSが提供する高度な機能を利用できず、CPUによって提供される非常に基礎的な機能しか利用できません。具体的には、ファイル読み書きやネットワーク通信、デバイスドライバ、更にはprintfを始めとした標準ライブラリが提供する関数群に至るまで、一切が利用できない事になります。もしこれらの機能が必要な場合は、０から実装しなければなりません。

hakase上ではこれらの高度な機能が利用可能です。そしてhakaseとfriendの間は非常に単純な仕組みによって通信、即ちデータのやり取りが可能です。これによって、本来ベアメタル上で実装しなければならない非本質的な処理をhakaseへとオフロードする事ができます。オフロードされる処理は、Linuxによって提供される高度な機能を活用して実装できるので、実装コストを大きく下げる事ができます。

## コア分離
hakaseとfriendは異なるコア上で実行されます。これによって、hakaseの下で動作するLinuxがfriendに干渉する事を防ぎます。全てのアプリケーションは明示的、或いは暗黙的にOSによる調停（介入）が行われます。また、保護機構によりアプリケーションがCPUの全機能にアクセスする事は禁止されています。friend上ではプロセッサコアが提供する全機能を、他のプログラムから介入を受ける事無く利用できます。これは、特権処理を0コストで実行できる事や、プリエンプションの影響を受けない事を含みます。

ただし、システムで共有するリソース（I/O等）については、Linuxによってそのリソースが管理されている事に注意しなければなりません。これは一般的なベアメタルプログラミングと大きく異なる所です。Linuxが管理しているI/Oデバイスをfriend側から無闇に制御しようとした場合、システムの停止や復旧不可能なトラブルを生み出す可能性があります。デフォルト設定ではToshokanはQEMUという仮想マシン上で実行されるため、安全にベアメタルコードを実行する事ができます。

コアは以下のように管理されます。まず、friendバイナリを実行していない間は、全てのコアはLinuxの管理下に置かれています。friendバイナリ実行時にhakase側でコアの割付を行う事により、一部のコアをfriend専用のコアとして隔離する事ができます。friend専用コアは初期化され、専用のメモリが割り当てられた後、friendバイナリのみが展開されます。ゆえに、friend専用コア上ではLinuxすらロードされません。hakaseプロセスが終了すると、正常終了、異常終了（セグメンテーションフォルト等の予期せぬクラッシュを含む）に関わらずfriendコアが解放され、再度Linuxの管理下に置かれます。

## メモリ空間
物理メモリ1GB-2GB（0x40000000 - 0x80000000）は、friend実行のためにシステムブート時に予約されます。これはすなわち、Toshokanを実行するシステム上では、1GB分の物理メモリが **friendコードの実行如何に関わらず** 使用できない、という事になります。

デフォルト設定では、ToshokanはQEMUという仮想マシン上で実行されるため、この事は一切問題になりませんが、仮想マシン上では無く実機上で実行する場合は、この事に気をつける必要があります。（詳細は実機実行の解説ページにて）

## メモリ共有
**ATTENTION:仮想メモリの仕組みを理解してから読む事をオススメします。**

friendの物理メモリはhakaseにも共有され、friendの初期設定のままでhakaseとfriend間で同じアドレスにアクセスすれば、同じデータを得る事ができます。この仕組みは単純です。まず、friendが使用する物理メモリは、hakase上にストレートマップされます。friendもまた、起動時に物理メモリ1GB-2GBを仮想メモリ1GB-2GBへストレートマップします。これは即ち、friend上で0x50000000にアクセスしても、hakase上で0x50000000にアクセスしても、それぞれ物理メモリ0x50000000を参照する事を意味します。要するに、hakaseからfriendの変数にアクセスする事が可能になります。

実際に使ってみると、あたかもhakaseがfriendの仮想メモリにアクセスできるように思えるかもしれません。しかしこれはあくまで錯覚で、hakaseはfriend用に予約された物理メモリにアクセスしているにすぎません。friendが物理メモリを仮想メモリへストレートマップしているために、実質的にhakaseがfriendの仮想メモリにアクセスできるようになっているだけです。そのため、friendコード上でページテーブルを変更した場合、これらの対応関係が崩れる可能性があります。対応関係を維持したい場合は、新規に作成するページ構造においても同様のストレートマップを行ってください。

また、friendはhakaseの仮想メモリにアクセスする事はできないと思ってください。hakaseのメモリ空間上には、hakaseのバイナリやスタック、ヒープ領域が展開されていますが、これらはhakaseとfriend間のメモリ共有の外に配置されています。ゆえに、 **friendからhakaseの変数にアクセスする事はできません。** function offloadingは一見するとfriendからhakaseの関数にアクセスできているように見えますが、原理は全く異なります。

## FriendLoaderの役割
FriendLoaderはLinux上にロードされるカーネルモジュールで、プロセッサコアとメモリの管理、並びにhakaseへのインターフェース提供を行います。hakaseバイナリやfriendバイナリはFriendLoaderのバージョンが異なると正常に動作しない可能性があります。
