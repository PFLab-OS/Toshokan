011: CPUの状態を知ろう
=============================

今回使用するディレクトリ：[sample/intro/011](https://github.com/PFLab-OS/Toshokan/tree/master/sample/intro/011)

[003](003.md)ではベアメタルプログラムがフリーズしたような状態になりました。もう皆さんは既にhlt命令の挙動をご存知だと思うので、hlt命令が実行された結果である事が分かっているかと思います。

しかし、何事も憶測で判断するのは危険です。もしかしたらhlt以外の部分で問題が起きていて、CPUが暴走しているのかもしれません。

これをはっきりさせるためには、CPUが今どういう状態にあるのかを知る必要があります。物理マシン上で動いているCPUの状態を知るには大変ですが、幸い今はベアメタルプログラムがエミュレータ上で動いているので、エミュレータのデバッグ情報を見ればCPUの状態を把握する事ができます。

011ディレクトリに003の編集後の状態を準備しました。（001のディレクトリには皆さんが独自に加えた変更等があるかもしれないですからね！その変更が今回の実験で悪影響を及ぼさないとも限らないので）

011ディレクトリ内のファイルは編集せずに、`make`してみましょう。相変わらず`hello!`と出た後固まってしまいますよね。それでは別のシェルを開いて、（ディレクトリは011のディレクトリで）以下のように叩いてみてください。

```bash
$ make attach_docker
```

これによってコンテナの中のシェルに入る事ができます。ひとまず`ls`でも叩いてみましょうか。

```bash
(コンテナ)~# ls 
cloud.qcow2  monitor  qemu  rsync  serial  ssh  ubuntu-16.04-server-cloudimg-amd64-disk1.diff.qcow2  ubuntu-16.04-server-cloudimg-amd64-disk1.qcow2
```

いろいろファイルがありますが、今回はこの中の`monitor`スクリプトを使います。

```bash
(コンテナ)~# ./monitor
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
QEMU 2.12.0 monitor - type 'help' for more information
(qemu) 
```

monitorスクリプトを実行すると、telnet経由でエミュレータのデバッグコンソールに接続します。

使い方は、このコンソール上でhelpと打つ他に、[公式マニュアル](https://en.wikibooks.org/wiki/QEMU/Monitor)も参考になります。

ひとまずここでは基礎的なコマンドを使ってみましょう。`cpu 1`と打った後に、`info registers`と打ってみてください。

Attention: `cpu 1`は重要なので、忘れずに打ってください。これを忘れるとデフォルトのcpu（=0）のレジスタ情報が表示されてしまいます。
今回のベアメタルプログラムはcpu 1で動いているので、cpu 1のレジスタ情報を取得する必要があります。

おおよそ以下のようになったでしょうか？（細かい数値はソースコードのアップデートに伴って少し異なっているかもしれません）

```bash
(qemu) cpu 1
(qemu) info registers
RAX=0000000000000000 RBX=00000000002001fe RCX=000000000000000a RDX=0000000000008f78
RSI=0000000000000000 RDI=0000000000008fa8 RBP=0000000000008fb8 RSP=0000000000008fa8
R8 =0000000000000000 R9 =0000000000000000 R10=0000000000000000 R11=0000000000000000
R12=0000000000000000 R13=0000000000000000 R14=0000000000000000 R15=0000000000000000
RIP=0000000000200224 RFL=00000002 [-------] CPL=0 II=0 A20=1 SMM=0 HLT=1
ES =0000 0000000000000000 0000ffff 00009300 DPL=0 DS   [-WA]
CS =0010 0000000000000000 00000000 00209a00 DPL=0 CS64 [-R-]
SS =0018 0000000000000000 00000000 00009300 DPL=0 DS   [-WA]
DS =0018 0000000000000000 00000000 00009300 DPL=0 DS   [-WA]
FS =0000 0000000000007000 0000ffff 00009300 DPL=0 DS   [-WA]
GS =0000 0000000000000000 0000ffff 00009300 DPL=0 DS   [-WA]
LDT=0000 0000000000000000 0000ffff 00008200 DPL=0 LDT
TR =0000 0000000000000000 0000ffff 00008b00 DPL=0 TSS64-busy
GDT=     0000000000097100 0000002f
IDT=     0000000000000000 0000ffff
CR0=80000011 CR2=0000000000000000 CR3=0000000080001000 CR4=000000b0
DR0=0000000000000000 DR1=0000000000000000 DR2=0000000000000000 DR3=0000000000000000 
DR6=00000000ffff0ff0 DR7=0000000000000400
EFER=0000000000000500
FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00009fc0
FPR0=0000000000000000 0000 FPR1=0000000000000000 0000
FPR2=0000000000000000 0000 FPR3=0000000000000000 0000
FPR4=0000000000000000 0000 FPR5=0000000000000000 0000
FPR6=0000000000000000 0000 FPR7=0000000000000000 0000
XMM00=0000000000ff0000000000ff00000000 XMM01=25252525252525252525252525252525
XMM02=0000000000000000ff00000000000000 XMM03=00000000000000000000000000000000
XMM04=0000000000000000000000ff00000000 XMM05=000000000000ff000000000000000000
XMM06=45516e76633a32312e322d7866303434 XMM07=000055ff966bd9b00000000000000061
XMM08=00000006ffffffff000055ff966b2c00 XMM09=00000000000000000000000000000000
XMM10=00000000000000000000000000000000 XMM11=00000000000000000000000000000000
XMM12=00000000000000000000000000000000 XMM13=00000000000000000000000000000000
XMM14=00000000000000000000000000000000 XMM15=00000000000000000000000000000000
```

この出力の`RIP=0000000000200224`という所から、CPU 1のインストラクションポインタ（次に実行する命令のアドレス）が0000000000200224である事が分かります。（皆さんの手元では違う値かもしれません。これ以降の値は皆さんの手元の値を用いて確認してください）
もし予想通りベアメタルプログラムがhlt命令で止まっているなら、0000000000200224の前の命令がhlt命令であるはずです。

x86のオペコードが可変長な事もあり、0x0000000000200224の直前に実行された命令がどのアドレスなのかを特定するのは少し難しいのですが、今回は直前がhlt命令だったと予想して、hlt命令のオペコードサイズである1を引いてみましょう。

Attention: 1を引くときは16進数である事に注意してください。

`x /10i 0x**********`とすると、指定したアドレス以降のメモリが逆アセンブルされます。0x0000000000200224から1を引いた0x0000000000200223について、逆アセンブルしてみましょう。

```bash
(qemu) x /10i 0x0000000000200223
0x00200223:  f4                       hlt      
0x00200224:  48 8d 45 f0              leaq     -0x10(%rbp), %rax
0x00200228:  be fe 07 20 00           movl     $0x2007fe, %esi
0x0020022d:  48 89 c7                 movq     %rax, %rdi
0x00200230:  e8 d2 fe ff ff           callq    0x200107
0x00200235:  48 8d 45 f0              leaq     -0x10(%rbp), %rax
0x00200239:  be 00 00 00 00           movl     $0, %esi
0x0020023e:  48 89 c7                 movq     %rax, %rdi
0x00200241:  e8 69 48 be fe           callq    0xfffffffffede4aaf
0x00200246:  07                       .byte    0x07
```

どうやら期待通りhlt命令で止まったみたいですね！皆さんの手元でも同じようになったでしょうか？

ちなみに、monitorからは`Ctrl+]`で抜ける事ができます。
QEMUを終了させるには、monitor上で`quit`と打つか、`make`を走らせたシェル（hello!と出力したまま固まっているシェル）でCtrl+Cを打ってください。

[このセクションの目次に戻る](index.md)
