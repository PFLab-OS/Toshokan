003: 特権命令を呼んでみよう
=============================

今回使用するディレクトリ：[sample/intro/001](https://github.com/PFLab-OS/Toshokan/tree/master/sample/intro/001)

Attention: 001のコードを引き続き使用します。

アプリケーションはx86 CPUがサポートしている全ての命令を呼べるわけではありません。特権命令と呼ばれる一部の命令はOSのみが呼べる命令です。
例えば、こんなコードを（ベアメタルではなく、普通のLinuxアプリケーションコードとして）書いてみたとしましょう。

```cpp
int main() {
  asm volatile("hlt;");
  return 0;
}
```

上のコードは、x86 CPUがサポートしているhltというアセンブリ命令を呼び出しています。
大変短いコードですが、このコードを実行すると、```Segmentation fault (コアダンプ)```等と出てアプリケーションがクラッシュするはずです。

Note: hlt命令はC言語から直接呼び出す事ができないので、C言語の中からアセンブリコードを呼び出す事ができる、インラインアセンブラという機能を用いています。これはgccに組み込まれた機能です。

hlt命令はRing0と呼ばれるモードで動いている時しか呼び出す事ができません。一方、アプリケーションはRing3と呼ばれるモードで動いています。これが上のコードがクラッシュした原因です。

Ring0で動いているソフトウェアはCPUの全ての命令を呼び出す事ができます。OSカーネルと呼ばれるソフトウェアは、Ring0で動く代表例です。

Attention: （詳しい人向け）ここでは説明を簡略化するため、Ring-1を無視した説明を行っています。

なぜRing0とRing3という２つのモードがあるのか、Ring1やRing2はどうなっているのか、少し気になりますよね。でもその話をすると長くなってしまうので、少し脇に置いておきましょう。

さて、CPUが最初起動した時はRing0で動いています。ベアメタルプログラムとは「OSが介在しない、CPUを直接制御できるプログラム」ですから、Ring0命令を呼び出す事ができそうですね。早速friend.ccで試してみましょう。

```bash
   //!!!!!!!!!!!!!!!!!!!!!!
   // add your codes here!
   //!!!!!!!!!!!!!!!!!!!!!!
+  asm volatile("hlt;");
 
   puts(f2h, "bye!");
```

さあこの一行を追加して`make`するとどうなるでしょうか？

Attention: 上記のdiffは、002で行った変更を破棄し、今回実験するコードと001との差のみを表示しています。

Hint: ファイルを変更したら上手く動かなくなってしまった時は、```git reset --hard HEAD```とすると、001に戻る事ができます。詳しくはgitの使い方を調べてみてください。

結果はどうだったでしょうか？```hello!```という文字列は表示されたものの、```bye!```という文字列が表示されないまま固まってしまいましたか？ひとまずCtrl+Cで`make`を終了させましょう。

なぜこのような結果になってしまったのかは、`hlt`という命令に理由がありそうです。`x86 hlt命令`でGoogle検索し、hlt命令が実行されると何が起こるのか、調べてみてください。

[このセクションの目次に戻る](index.md)
